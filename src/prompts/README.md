# Prompt Generation Module

Complete prompt engineering system for Fredholm integral equations using OOP design with base classes and style inheritance.

**Equation Types Supported:**
- **Second kind** (well-posed): `u(x) - λ ∫_a^b K(x, t) u(t) dt = f(x)` - All original dataset equations
- **First kind** (ill-posed): `∫_a^b K(x, t) u(t) dt = g(x)` - Generated by ill_posed augmentation strategy

All prompts are generic and handle both equation types. First kind equations require regularization techniques (Tikhonov, Landweber, TSVD).

## Architecture

### Base Classes (`src/prompts/base.py`)

**PromptStyle (Abstract Base Class)**
- Defines interface for all prompt styles
- Methods: `get_system_prompt()`, `get_user_prompt()`, `generate()`, `generate_batch()`
- Handles metadata and ground truth management

**Data Classes**
- `EquationData` - Container for equation parameters (u, f, kernel, lambda_val, a, b)
- `GeneratedPrompt` - Result object with prompt, style, metadata, ground_truth

### Style Implementations (`src/prompts/styles/`)

Each style extends `PromptStyle` base class:

1. **BasicPromptStyle** - Simple direct prompts
2. **ChainOfThoughtPromptStyle** - Step-by-step reasoning  
3. **FewShotPromptStyle** - Includes worked examples
4. **ToolAssistedPromptStyle** - Enables computational tools

### Factory Pattern (`src/prompts/factory.py`)

```python
create_prompt_style(
    style: str,
    include_examples: bool = True,
    num_examples: int = 2,
    edge_case_mode: str | EdgeCaseMode = "none"
) -> PromptStyle

create_edge_case_mode(
    mode: str = "none",  # "none", "guardrails", "hints"
    hint_fields: list[str] | None = None  # ["has_solution", "solution_type"]
) -> EdgeCaseMode
```

### Batch Processing (`src/prompts/batch_processor.py`)

**BatchPromptProcessor**
- CSV → JSONL pipeline
- Progress tracking
- Format inference (infix/latex/rpn)
- Metadata preservation

## Usage

### Direct Style Usage

```python
from src.prompts import create_prompt_style, EquationData

# Create style
style = create_prompt_style("chain-of-thought")

# Create equation
eq = EquationData(
    u="x**2",
    f="x**2 + 2*x",
    kernel="x*t",
    lambda_val=0.5,
    a=0.0,
    b=1.0
)

# Generate prompt
prompt = style.generate(eq, include_ground_truth=True)
print(prompt.prompt)
```

### Batch Processing

```python
from src.prompts import create_processor

processor = create_processor(
    style="few-shot",
    output_dir="data/prompts",
    include_ground_truth=True
)

output_file = processor.process_dataset(
    "data/processed/train_infix.csv",
    format_type="infix"
)
```

### Edge Case Modes

Handle edge cases with 3 modes to control how the model is guided about solution types:

```python
from src.prompts import create_prompt_style, EquationData

# MODE 1: "none" - Pure inference, no edge case instructions
style = create_prompt_style("basic", edge_case_mode="none")

# MODE 2: "guardrails" - Add instructions about possible solution types
style = create_prompt_style("basic", edge_case_mode="guardrails")

# MODE 3: "hints" - Include actual edge case field values in prompt
style = create_prompt_style("basic", edge_case_mode="hints")

# Equation with edge case data
eq = EquationData(
    u="No solution",
    f="x**2",
    kernel="0",
    lambda_val=1.0,
    a=0.0,
    b=1.0,
    # Edge case fields (optional)
    has_solution=False,
    solution_type="none",
)

prompt = style.generate(eq)
```

#### Mode Details

**Mode 1: `none` (Pure Inference)**
- **Use case**: Test model's ability to recognize edge cases without guidance
- **Added to prompt**: Nothing
- **Example output**: Standard prompt with no edge case instructions
- **Recommended for**: Final evaluation, zero-shot capability testing

**Mode 2: `guardrails` (Instructional)**
- **Use case**: Guide model without revealing the answer
- **Added to system prompt**:
  ```
  Note: Solutions may take different forms:
  - Exact symbolic (e.g., u(x) = sin(x))
  - Exact with unknown coefficients (e.g., u(x) = c₁sin(x) + c₂cos(x))
  - Approximate with coefficients to determine (e.g., u(x) ≈ a₀ + a₁x + a₂x²)
  - Discrete points only
  - Infinite series (e.g., u(x) = Σ aₙxⁿ)
  - Family of solutions (multiple valid solutions)
  - Ill-posed requiring regularization
  - No solution exists
  
  State clearly which type applies and provide appropriate representation.
  ```
- **Recommended for**: Training with edge case awareness, helping model learn taxonomy

**Mode 3: `hints` (Ground Truth Hints)**
- **Use case**: Train model to recognize solution patterns when given metadata
- **Added to prompt end**: `[Has solution: Yes/No, Type: <solution_type>]`
- **Example with hints**:
  ```
  Solve: u(x) - λ∫K(x,t)u(t)dt = f(x)
  [Has solution: No, Type: none]
  ```
- **Includes guardrails**: Yes, guardrails text is also added to system prompt
- **Recommended for**: Supervised training, conditional generation, evaluation with metadata

#### Workflow Recommendations

**Training Pipeline**:
1. Start with `hints` mode - Model learns to map metadata → solution strategy
2. Progress to `guardrails` mode - Model internalizes the taxonomy without explicit hints
3. Evaluate with `none` mode - Test zero-shot edge case recognition

**Production Use**:
- Use `guardrails` for better results when model might encounter edge cases
- Use `none` for benchmarking true capability
- Use `hints` when you have metadata and want conditional generation

**Edge case fields** (used in hints mode):
- `has_solution`: `True`/`False` - whether a solution exists
- `solution_type`: one of:
  - `exact_symbolic` - closed-form symbolic solution (e.g., u(x) = sin(x))
  - `approx_coef` - approximate with NUMERIC coefficients (e.g., u(x) = 0.5*sin(x) + 1.2*x)
  - `discrete_points` - solution defined only at discrete points
    - `series` - truncated series with exactly 4 explicit terms
  - `family` - family of solutions with ARBITRARY parameters (e.g., u(x) = c₁*sin(x) + c₂*cos(x))
  - `regularized` - ill-posed equation requiring regularization
  - `none` - no solution exists

### CLI Commands

```bash
# Generate prompts for dataset
uv run python -m src.cli prompt generate train.csv \
    --style chain-of-thought \
    --output data/prompts \
    --edge-case-mode hints

# Generate with guardrails (no hints, but edge case instructions)
uv run python -m src.cli prompt generate train.csv \
    --style few-shot \
    --edge-case-mode guardrails

# Batch process multiple files
uv run python -m src.cli prompt batch data/processed/ \
    --styles "basic,few-shot" \
    --pattern "train_*.csv"
```

## Module Structure

```
src/prompts/
├── __init__.py          # Public exports
├── base.py              # Base classes (PromptStyle, EquationData, EdgeCaseMode)
├── factory.py           # Factory functions (create_prompt_style, create_edge_case_mode)
├── batch_processor.py   # BatchPromptProcessor class
├── templates.py         # Shared templates and examples
└── styles/
    ├── __init__.py
    ├── basic.py              # BasicPromptStyle
    ├── chain_of_thought.py   # ChainOfThoughtPromptStyle
    ├── few_shot.py           # FewShotPromptStyle
    └── tool_assisted.py      # ToolAssistedPromptStyle
```

## Design Principles

✅ **Single Responsibility** - Each style class handles one prompt type
✅ **Open/Closed** - Easy to add new styles by extending `PromptStyle`
✅ **Liskov Substitution** - All styles interchangeable via base class
✅ **Interface Segregation** - Clear abstract methods in base class
✅ **Dependency Inversion** - Depend on `PromptStyle` abstraction

## Structured Output Format

All prompt styles instruct the LLM to output in a structured format for reliable evaluation:

```
SOLUTION: u(x) = [solution expression in detected format]
HAS_SOLUTION: [yes/no]
SOLUTION_TYPE: [exact_symbolic/approx_coef/discrete_points/series/family/regularized/none]
```

**Format-Specific Generation**: The prompt generation system automatically detects the input format and provides **targeted format instructions**:
- Processing: `*_infix.csv` → Prompt says: "Express your solution in infix notation (e.g., x**2 + sin(x), exp(-x)*cos(x))."
- Processing: `*_latex.csv` → Prompt says: "Express your solution in LaTeX notation (e.g., x^2 + \sin(x), e^{-x}\cos(x))."
- Processing: `*_rpn.csv` → Prompt says: "Express your solution in Reverse Polish Notation (e.g., x 2 ^ x sin +, x neg exp x cos *)."

This ensures:
- **Clearer instructions**: LLM knows exactly what format to use (no ambiguity or conditional logic)
- **Format-specific prompts**: Each dataset variant gets prompts tailored to its format
- **Consistent evaluation**: Solutions match ground truth format for direct comparison

**Why structured output?**
- **Reliable parsing**: `src/llm/postprocess.py` extracts these fields with regex
- **Edge case evaluation**: Can verify if LLM correctly identified no-solution cases, ill-posed problems, etc.
- **Solution type accuracy**: Compare predicted solution_type vs ground truth
- **Automated metrics**: Calculate accuracy for has_solution and solution_type classification

**Example LLM response**:
```
Let me solve this step by step...
[reasoning steps here]

SOLUTION: u(x) = sin(x)
HAS_SOLUTION: yes
SOLUTION_TYPE: exact_symbolic
```

**Postprocessing extracts**:
```python
{
  "solution_str": "sin(x)",
  "solution_sympy": sin(x),
  "has_solution": True,
  "solution_type": "exact_symbolic",
  "reasoning": "...",
  "confidence": 0.8
}
```

**Evaluation metrics available**:
- Solution correctness (symbolic/numeric comparison)
- `has_solution` accuracy (binary classification)
- `solution_type` accuracy (8-class classification)
- Edge case recognition rate

## Adding New Styles

```python
from src.prompts.base import PromptStyle, EquationData

class CustomPromptStyle(PromptStyle):
    def __init__(self, **kwargs):
        super().__init__(style_name="custom", **kwargs)
    
    def get_system_prompt(self) -> str:
        return "Your custom system prompt..."
    
    def get_user_prompt(self, equation: EquationData, format_type: str) -> str:
        return f"Solve: {equation.f} with kernel {equation.kernel}"
```

Then register in `factory.py`:

```python
def create_prompt_style(style: str, ...) -> PromptStyle:
    styles = {
        ...
        "custom": CustomPromptStyle,
    }
```

## Tests

All 30 tests passing:
- EquationData creation
- All 4 prompt styles
- Edge case modes
- Batch processing
- JSONL export
- Factory functions

Run tests:
```bash
uv run pytest tests/test_prompt_generation.py -v
```
